
<!-- saved from url=(0150)https://learn.uark.edu/bbcswebdav/pid-10801989-dt-content-rid-118008947_1/courses/MASTER-1219-THEUA-CSCE-3193-SEC001/CSCE3193_A3_instructions_f21.html -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, ::-webkit-calendar-picker-indicator, embed[type="application/pdf"] {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><script class="darkreader darkreader--proxy">(function injectProxy() {
        document.dispatchEvent(
            new CustomEvent("__darkreader__inlineScriptsAllowed")
        );
        const addRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "addRule"
        );
        const insertRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "insertRule"
        );
        const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "deleteRule"
        );
        const removeRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "removeRule"
        );
        const shouldWrapDocStyleSheets =
            location.hostname.endsWith("pushbullet.com") ||
            location.hostname.endsWith("ilsole24ore.com") ||
            location.hostname.endsWith("allegro.pl");
        const documentStyleSheetsDescriptor = shouldWrapDocStyleSheets
            ? Object.getOwnPropertyDescriptor(Document.prototype, "styleSheets")
            : null;
        const cleanUp = () => {
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "addRule",
                addRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "insertRule",
                insertRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "deleteRule",
                deleteRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "removeRule",
                removeRuleDescriptor
            );
            document.removeEventListener("__darkreader__cleanUp", cleanUp);
            document.removeEventListener(
                "__darkreader__addUndefinedResolver",
                addUndefinedResolver
            );
            if (shouldWrapDocStyleSheets) {
                Object.defineProperty(
                    Document.prototype,
                    "styleSheets",
                    documentStyleSheetsDescriptor
                );
            }
        };
        const addUndefinedResolver = (e) => {
            customElements.whenDefined(e.detail.tag).then(() => {
                document.dispatchEvent(
                    new CustomEvent("__darkreader__isDefined", {
                        detail: {tag: e.detail.tag}
                    })
                );
            });
        };
        document.addEventListener("__darkreader__cleanUp", cleanUp);
        document.addEventListener(
            "__darkreader__addUndefinedResolver",
            addUndefinedResolver
        );
        const updateSheetEvent = new Event("__darkreader__updateSheet");
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            const returnValue = insertRuleDescriptor.value.call(
                this,
                rule,
                index
            );
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !this.ownerNode.classList.contains("darkreader")
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyDocumentStyleSheets() {
            const docSheets = documentStyleSheetsDescriptor.get.call(this);
            const filtered = [...docSheets].filter((styleSheet) => {
                return !styleSheet.ownerNode.classList.contains("darkreader");
            });
            return Object.setPrototypeOf(filtered, StyleSheetList.prototype);
        }
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "addRule",
            Object.assign({}, addRuleDescriptor, {value: proxyAddRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "insertRule",
            Object.assign({}, insertRuleDescriptor, {value: proxyInsertRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "deleteRule",
            Object.assign({}, deleteRuleDescriptor, {value: proxyDeleteRule})
        );
        Object.defineProperty(
            CSSStyleSheet.prototype,
            "removeRule",
            Object.assign({}, removeRuleDescriptor, {value: proxyRemoveRule})
        );
        if (shouldWrapDocStyleSheets) {
            Object.defineProperty(
                Document.prototype,
                "styleSheets",
                Object.assign({}, documentStyleSheetsDescriptor, {
                    get: proxyDocumentStyleSheets
                })
            );
        }
    })()</script><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #181a1b !important;
}
html, body, input, textarea, select, button {
    background-color: #181a1b;
}
html, body, input, textarea, select, button {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #555b00 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
	<style>
		.toc {
			margin-left: 30px;
		}
		.code {
			margin-left: 30px;
			color:#000000;
			background-color:#ffffff;
		}
		.shell {
			margin-left: 30px;
			color:#000000;
			background-color:#ffffff;
		}
	</style><style class="darkreader darkreader--sync" media="screen"></style>
<script data-dapp-detection="">!function(){let e=!1;function n(){if(!e){const n=document.createElement("meta");n.name="dapp-detected",document.head.appendChild(n),e=!0}}if(window.hasOwnProperty("ethereum")){if(window.__disableDappDetectionInsertion=!0,void 0===window.ethereum)return;n()}else{var t=window.ethereum;Object.defineProperty(window,"ethereum",{configurable:!0,enumerable:!1,set:function(e){window.__disableDappDetectionInsertion||n(),t=e},get:function(){if(!window.__disableDappDetectionInsertion){const e=arguments.callee;e&&e.caller&&e.caller.toString&&-1!==e.caller.toString().indexOf("getOwnPropertyNames")||n()}return t}})}}();</script><meta name="darkreader" content="d9a3c15be689b44ac80e67a4266bdac4"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
a[href="https://coinmarketcap.com/"] > svg[width="94"][height="16"] > path {
    fill: var(--darkreader-neutral-text) !important;
}
#edge-translate-panel-body {
    color: var(--darkreader-neutral-text) !important;
}</style></head>
<body bgcolor="#d8ccdb" data-darkreader-inline-bgcolor="" style=""><br><br>
<table align="center" cellpadding="50" border="1" bgcolor="#e8dceb" width="620" data-darkreader-inline-bgcolor="" style=""><tbody><tr><td>

<h1>Objects</h1>

<p>In this assignment, you will build a map editor for a side-scroller video game.</p>

<ol>
	<li><b>Make a backup copy</b> of your previous assignment.
		If you do not already have a habit of regularly backing up your work, develop that habit now.
		These days, storage space is cheap. No one regrets making backups. You have been warned.
		</li><br><br>

	<li><b>Make a class named "Brick"</b>.
		Give it four integer member variables, named "x", "y", "w", and "h", to hold the position and dimensions of the brick.
		</li><br><br>

	<li><b>Clean up</b>.
		If you still have a button or a turtle in your program, remove those.
		When you program, it is important to stay organized.
		Always take time to use meaningful variable names, indent your code properly, add comments, and keep it readable.
		I am not going to evaluate at your code. This is for you.
		These assignments build on top of each other.
		If you make a complicated mess, you are the one who will have to deal with it later.
		</li><br><br>

	<li><b>Make your model hold an ArrayList of Bricks</b>.
		(Use your favorite search engine to search for "java ArrayList". Read about the "add", "get", and "remove" methods.)
		Add a member variable to your model like this:
<pre class="code">	ArrayList&lt;Brick&gt; bricks;
</pre>
		Initialize it in your model constructor like this:
<pre class="code">		bricks = new ArrayList&lt;Brick&gt;();
</pre>
		Also, let's add a Brick to the Arraylist:
<pre class="code">		Brick b = new Brick(400, 300, 200, 100);
		bricks.add(b);
</pre>
		</li><br><br>

	<li><b>Make your View draw all of the bricks</b>.
		Use a search engine to find API documentation for the Java Graphics class.
		Find a method that will enable you to draw a box.
<pre class="code">for(int i = 0; i &lt; model.bricks.size(); i++)
{
	Brick b = model.bricks.get(i);
	g.drawBox(b.x, b.y, b.w, b.h); // Note: drawBox is
	                               // not a real method
	                               // in the Graphics class.
	                               // Use the API docs
	                               // to find a real one.
}
</pre>
		</li><br><br>

	<li><b>Add a brick where the user indicates with the mouse</b>.
		The user will click, drag, and release the mouse button.
		A new brick should be placed with corners indicated by the location where the mouse was pressed and released.
		The user should be able to add as many bricks to the screen as he or she likes.
		(Also, get rid of that one brick that we initially put in the ArrayList.
		That was just there so you could see if the previous step worked.)
		</li><br><br>

	<li><b>Enable the View to scroll over a larger model</b>.
		Add a variable to the Model class to store a "camera" position.
		When you draw the bricks, subtract the camera position from the horizontal position of the brick
		For example:
<pre class="code">			g.drawBox(b.x - model.cameraPos, b.y, b.w, b.h);
</pre>
		Adjust the scroll position value when the user presses the left or right arrow keys.
		(Adjust by some value greater than 1, so it is not painfully slow.)
		</li><br><br>

	<li><b>Read about JSON format</b>.
		JSON is a text-based format for encoding arbitrary objects.
		Visit <a href="http://json.org/">http://json.org</a> and examine the pictures.
		If you don't understand them, find a tutorial about JSON and figure out what it is all about.
		There is a Java class that enables one to load or save in JSON format on the Blackboard site called Json.java.
		Download it, add it to your project, and study the example usage in the comments at the top of the file.
		</li><br><br>

	<li><b>When the user presses 's', save your model to a Json file</b>.
		Add a "marshall" method to your Brick class that marshalls the object into a Json node.
		Also, add a "marshall" method to your Model class that marshalls it into a Json node.
		Use the Json.save method to save the Json node to a file named "map.json".
		</li><br><br>

	<li><b>When the user presses 'l', load the model from a Json file</b>.
		Add an unmarshalling constructor to your Brick class that will initialize its four member variables from Json objects.
		Also, add a method to your model class that will clear the ArrayList of bricks and unmarshal them from Json objects.
		Use the Json.load method to load the Json node from "map.json".
		</li><br><br>
	<li><b>Test your code and submit.</b>
		Make a zip archive called Assignment3.zip containing your source files, image files, and a working build script.  
		Do not submit any .class files or .jar files. Your build script should build and execute the program.
		Test your zip file before you submit it by extracting into a separate folder and running your build script.
		Finally, go the course web site on Blackboard (<a href="https://learn.uark.edu/">https://learn.uark.edu/</a>) and 
		submit your zip archive for Assignment3.
		</li><br><br>
</ol>
















<h2>FAQ:</h2>
<ol>

	<li><b>Q: How does one use a try/catch block?</b><br>
		A: If you <u>must</u> use a try/catch block, make sure the catch part does not hide any errors.
		A good way to inform the user about an error is to print a stack trace and terminate the program.
		(If you don't terminate the program, you might not even notice that something bad happened.)
		Here is an example of a well-crafted try/catch block:
<pre class="code">try
{
	image = ImageIO.read(new File("filename.png"));
}
catch(Exception e)
{
	e.printStackTrace(System.err);
	System.exit(1);
}
</pre>
		Here is an example of the wrong way to use a try/catch block:
<pre class="code">try
{
	image = ImageIO.read(new File("filename.png"));
}
catch(Exception e) {}   <font color="red" data-darkreader-inline-color="" style="--darkreader-inline-color:#ff1a1a;">// BAD, BAD, BAD!!!!!!</font>
</pre>
		Also, it is a good idea to put as little code as you can inside the try section.
		</li><br><br>

</ol>

</td></tr></tbody></table>

</body></html>